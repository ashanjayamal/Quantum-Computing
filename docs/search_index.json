[["index.html", "Introduction to Quantum Computing Chapter 1 Quantum Computing: A Journey into the Atomic World", " Introduction to Quantum Computing Ashan Jayamal 2025-03-09 Chapter 1 Quantum Computing: A Journey into the Atomic World Resourse: www.information-age.com As circuit components continue to shrink, reaching the atomic realm of energy and matter, the influence of quantum effects has become increasingly significant. Rather than viewing these effects as challenges, researchers recognized their potential to enable more efficient computations. In the early 1980s, both Paul Benioff and Richard Feynman independently proposed quantum models of computation. These pioneering ideas demonstrated how quantum mechanics could be applied to computing, laying the groundwork for a new paradigm. The limitations of classical computers, bound by conventional models, drove researchers to explore quantum computing more deeply. Over the decades, this unconventional approach has garnered significant attention due to remarkable theoretical and experimental advancements. Quantum computing aims to solve complex computational problems efficiently by harnessing the power of quantum effects, such as superposition and entanglement. Today, it represents a bold step forward in the quest for revolutionary technologies that transcend the boundaries of classical computation. Resource: Quantumpedia "],["quntum-effects.html", "Chapter 2 Quntum Effects 2.1 Superposition 2.2 Measurement 2.3 Unitary Evolution 2.4 Entanglement", " Chapter 2 Quntum Effects 2.1 Superposition A pure state in quantum mechanics is represented in terms of a normalised vector is \\(|\\psi\\rangle\\) in a complex inner product space \\(\\mathcal{H}\\) (called Hilbert space). The notation \\(|\\psi\\rangle\\) is used for quantum states, represented by column vectors, and it is called a ket vector; while the conjugate transpose of the \\(|\\psi\\rangle\\) is called the bra vector \\((\\langle\\psi|)\\), leading to bra-ket, known as Dirac notation. Inner product \\((\\psi,\\phi)\\) is expressed as \\(\\langle\\psi|\\phi\\rangle\\). Accordingly, the normalisation condition can be stated as \\(\\langle\\psi|\\psi\\rangle = 1\\). ket vector bra vector \\(| \\psi \\rangle = \\begin{pmatrix} a \\\\ b \\end{pmatrix}\\) \\(\\langle\\psi| = \\begin{pmatrix} \\bar{a} &amp; \\bar{b} \\end{pmatrix}\\) Remark. \\[\\langle \\psi_1 | \\psi_2 \\rangle = \\overline{\\langle \\psi_2 | \\psi_1 \\rangle}\\] Accordingly, it is possible to handle inner and outer products conveniently. \\[| \\psi \\rangle \\langle \\phi | = \\begin{pmatrix} a\\bar{c} &amp; a \\bar{d} \\\\ b\\bar{c} &amp; b \\bar{d} \\end{pmatrix}\\] where \\(| \\psi \\rangle = \\begin{pmatrix} a \\\\ b \\end{pmatrix}\\) and \\(| \\phi \\rangle = \\begin{pmatrix} c \\\\ d \\end{pmatrix}\\) We refer to the Euclidean norm when defining the sizes of vectors. That is, \\[|| \\psi || = | \\langle \\psi | \\psi \\rangle |.\\] If the two states \\(|\\psi_1\\rangle\\) and \\(|\\psi_2\\rangle\\) are physical states of the system, then their linear superposition \\(c_1 |\\psi_1\\rangle + c_2 |\\psi_1\\rangle\\) is also a possible state of the same system, where \\(c_1\\) and \\(c_2\\) are complex numbers satisfying \\(| c_1 |^2 + | c_2 |^2 = 1\\). This is called the superposition principle, and is extendable to any number of states, by considering appropriate basis states. Consider an electron that has either spin up or down. We now state the states with respect to the basis up \\(|↑\\rangle\\) and down \\(|↓\\rangle\\) states. Resource: Hughes, Ciaran, et al. Quantum computing for the quantum curious. Springer Nature, 2021. A possible state of the electron \\[| \\psi \\rangle = \\sqrt{\\frac{2}{3}} | ↑ \\rangle + \\frac{i}{\\sqrt{3}} | ↓ \\rangle\\] because \\(\\left| \\sqrt{\\frac{2}{3}} \\right|^2 + \\left| \\frac{i}{\\sqrt{3}} \\right|^2 = \\frac{2}{3} + \\frac{1}{3} = 1\\) 2.2 Measurement In quantum mechanics, there is an operator corresponding to each dynamical observable of classical physics, such as position, momentum, spin, etc. This operator is mathematically expressed by a Hermitian matrix acting on the Hilbert space \\(\\mathcal{H}\\). Let \\(a\\) be an observable and \\(A\\) be the corresponding Hermitian operator acting on the Hilbert space \\(\\mathcal{H}\\). When \\(a\\) is measured, one of the eigenvalues of \\(A\\) is obtained, and the system suddenly changes to the corresponding eigenstate. Eigenvalues of Hermitian matrices are real and eigenvectors corresponding to different eigenvalues are orthogonal. The system collapses to state \\(|\\lambda_1\\rangle\\) and we obtain the eigenvalue \\(\\lambda_1\\): \\[c_1|\\lambda_1\\rangle + c_2|\\lambda_2\\rangle \\rightarrow |\\lambda_1\\rangle\\] Or, to state \\(|\\lambda_2\\rangle\\) and we obtain the eigenvalue \\(\\lambda_2\\): \\[c_1|\\lambda_1\\rangle + c_2|\\lambda_2\\rangle \\rightarrow |\\lambda_2\\rangle\\] \\[|↑\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, |↓\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}.\\] Corresponding spin operator (Hermitian matrix) (Pauli z-matrix): \\(\\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix}\\) Eigenstates \\(|↑\\rangle\\) and \\(|↓\\rangle\\), with eigenvalues \\(\\pm 1\\): \\[\\sigma_z|↑\\rangle = |↑\\rangle,\\sigma_z|↓\\rangle = -|↓\\rangle\\] A quantum measurement is described by a set of measurement operators \\(\\{M_a\\}\\), which operate on the state of the system. Consider: \\(|\\psi\\rangle = c_1|\\lambda_1\\rangle + c_2|\\lambda_2\\rangle\\). The probability of collapsing to state \\(|\\lambda_i\\rangle\\) is given by \\(|c_i|^2\\). Note that \\(|c_1|^2 + |c_2|^2 = 1\\).Therefore, \\(c_1\\) and \\(c_2\\) are called probability amplitudes. Example 2.1 Consider \\[\\psi\\rangle = \\frac{2}{3}|↑\\rangle + \\frac{i}{3}|↓\\rangle\\] Probability of collapsing to spin-up: \\(\\frac{2}{3}\\) Probability of collapsing to spin-down: \\(\\frac{1}{3}\\) This is also stated as follows in another approach: Consider an experimental setup which is described by an observable \\(a\\) (with corresponding Hermitian operator \\(A\\)) to be measured and state \\(|\\psi\\rangle\\) of the system. Then the expectation value \\(⟨A\\rangle\\) of \\(a\\) after measurements with respect to a state \\(|\\psi\\rangle\\) is given by: \\(⟨A\\rangle =\\langle\\psi|A|\\psi\\rangle\\). Example 2.2 Calculating the expectation value of \\(\\sigma_z\\) (Pauli \\(z\\)-matrix) for the given state: \\[ |\\psi\\rangle = \\sqrt{\\frac{2}{3}} |0\\rangle + \\frac{i}{\\sqrt{3}} |1\\rangle. \\] Then, \\[ |\\psi\\rangle = \\sqrt{\\frac{2}{3}} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} + \\frac{i}{\\sqrt{3}} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\sqrt{\\frac{2}{3}} \\\\ \\frac{i}{\\sqrt{3}} \\end{pmatrix}. \\] \\[\\sigma_z|\\psi\\rangle= \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix} \\begin{pmatrix} \\sqrt{\\frac{2}{3}} \\\\ \\frac{i}{\\sqrt{3}} \\end{pmatrix} = \\begin{pmatrix} \\sqrt{\\frac{2}{3}} \\\\ -\\frac{i}{\\sqrt{3}} \\end{pmatrix}. \\] \\[ \\langle \\psi | = \\begin{pmatrix} \\sqrt{\\frac{2}{3}} &amp; -\\frac{i}{\\sqrt{3}} \\end{pmatrix}. \\] So, \\[ \\langle \\psi |\\sigma_z|\\psi\\rangle = \\begin{pmatrix} \\sqrt{\\frac{2}{3}} &amp; -\\frac{i}{\\sqrt{3}} \\end{pmatrix} \\begin{pmatrix} \\sqrt{\\frac{2}{3}} \\\\ -\\frac{i}{\\sqrt{3}} \\end{pmatrix}=\\frac{2}{3} + \\frac{1}{3} = 1. \\] Henece, \\[\\text{The expectation value of } \\sigma_z = \\langle \\sigma_z \\rangle = 1. \\] Measurement can be regarded as an operation that is possible to perform with respect to any orthonormal basis. The following basis is called the Hadamard basis: \\[|+\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle\\] \\[|−\\rangle = \\frac{1}{\\sqrt{2}}|1 − \\rangle \\frac{1}{\\sqrt{2}}|1\\rangle\\] Exercise 2.1 \\[|\\psi\\rangle = \\frac{2}{3}|0\\rangle + \\frac{i}{3}|1\\rangle\\] What happens if this is measured with respect to the Hadamard basis? Solution: We can obtain easily \\[ \\begin{eqnarray} |0\\rangle&amp;=\\frac{1}{\\sqrt{2}}\\left(|+\\rangle+|+\\rangle\\right)\\\\ |1\\rangle&amp;=\\frac{1}{\\sqrt{2}}\\left(|+\\rangle+|-\\rangle\\right)\\\\ \\end{eqnarray} \\] Then, \\[ \\begin{eqnarray} |\\psi\\rangle &amp;=&amp;\\frac{2}{3}|0\\rangle + \\frac{i}{3}|1\\rangle\\\\ &amp;=&amp;\\frac{2}{3}\\left(\\frac{1}{\\sqrt{2}}\\left(|+\\rangle+|-\\rangle\\right)\\right)+ \\frac{i}{3}\\left(\\frac{1}{\\sqrt{2}}\\left(|+\\rangle-|-\\rangle\\right)\\right)\\\\ &amp;=&amp;\\frac{1}{\\sqrt{2}}\\left(\\frac{2+i}{3}|+\\rangle+\\frac{2-i}{3}|-\\rangle\\right)\\\\ &amp;=&amp;\\frac{2+i}{3\\sqrt{2}}|+\\rangle+\\frac{2-i}{3\\sqrt{2}}|-\\rangle \\end{eqnarray} \\] 2.3 Unitary Evolution Erwin Schrödinger (Resource:Wikipidia) The time evolution of a closed quantum system is governed by the Schrödinger equation: \\[i\\hbar \\frac{d}{dt}|\\psi(t)⟩ = H|\\psi(t)⟩\\] where: - \\(\\hbar\\) is the reduced Planck’s constant. - \\(H\\) is the Hamiltonian of the system (a Hermitian operator). Remark. The following is a solution to the Schrödinger equation: \\[|\\psi(t_2)\\rangle = e^{\\frac{i H}{\\hbar} (t_1 - t_2)} |\\psi(t_1)\\rangle.\\] Note that \\(e^{\\frac{i H}{\\hbar} (t_1 - t_2)}\\) is a unitary. Verfication This leads to the notion of unitary evolution of a quantum system. The gate model of quantum computing is based on this idea. A quantum gate is a unitary matrix, acting on a quantum state, called a qubit. 2.4 Entanglement Consider a quantum system consisting of two components; one in a Hilbert space \\(\\mathcal{H}_1\\) and the other in another Hilbert space \\(\\mathcal{H}_2\\). Then the system as a whole is in Hilbert space \\(\\mathcal{H} = \\mathcal{H}_1 \\otimes \\mathcal{H}_2\\). \\[ |\\psi\\rangle =\\sum_{i,j}c_{i,j}|e_{1,j}\\rangle \\otimes |e_{2,j}\\rangle \\] ,where \\(|\\psi\\rangle\\): Composite state \\(|e_{1,j}\\rangle\\): Orthonormal basis for \\(\\mathcal{H}_1\\) \\(|e_{2,j}\\rangle\\): Orthonormal basis for \\(\\mathcal{H}_2\\) single qubit \\(|\\uparrow\\rangle=|0\\rangle=\\begin{pmatrix}1\\\\0\\end{pmatrix}\\) "],["quantum-gates.html", "Chapter 3 Quantum Gates 3.1 Hadamard gate 3.2 Pauli gates 3.3 CNOT gate", " Chapter 3 Quantum Gates Action of an arbitrary single qubit quantum gate: Notation: Outer Product Notation: Suppose a single-qubit quantum gate \\(A\\) transforms \\(|0\\rangle\\) into \\(|\\psi_0\\rangle\\) and \\(|1\\rangle\\) into \\(|\\psi_1\\rangle\\). Then the outer product representation of \\(A\\) is given by: \\[ A = |\\psi_0\\rangle\\langle 0| + |\\psi_1\\rangle\\langle 1|. \\] 3.1 Hadamard gate Hadamard gate is of particular importance, as it enables Hadamard transformation. The Hadamard gate is represented as: \\[ H = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{pmatrix} \\] The Hadamard gate transforms basis states as follows: \\[ \\begin{eqnarray} H|0\\rangle &amp;=&amp; \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}} (|0\\rangle + |1\\rangle)\\tag{3.1}\\\\ H|1\\rangle &amp;=&amp; \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}} (|0\\rangle - |1\\rangle)\\tag{3.2} \\end{eqnarray} \\] The computational basis \\(\\{|0\\rangle, |1\\rangle\\}\\) is mapped to the Hadamard basis ({|+,|-) Hadamard gate is often used in quantum algorithms to make equal superposition of states. Exercise 3.1 What is the outer product representation of the Hadamard gate? Solution The outer product representation of the Hadamard gate can be expressible as: \\[ H|x\\rangle=|+\\rangle + \\langle 0| + |-\\rangle\\langle 1| \\] Further, By (3.1) and (3.2) we get, \\[ H|x\\rangle=\\frac{1}{\\sqrt{2}} \\big(|0\\rangle + (-1)^x |1\\rangle\\big) \\] In compact form, the action of Hadamard gate can be expressed as \\[ H=\\frac{1}{\\sqrt{2}}\\sum_{x,y\\in\\{0,1\\}}(-1)^{xy} |x\\rangle \\langle y|. \\] 3.2 Pauli gates As in classical gates, there is a in quantum computing. The role of a quantum NOT gate is transforming \\(|0\\rangle\\) into \\(|1\\rangle\\) and \\(|1\\rangle\\) to \\(|0\\rangle\\). It turns out that the Pauli x-matrix does this task. Therefore, the corresponding gate is called as well. \\[ X = \\sigma_x = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\] Exercise 3.2 What is the Outer-product representation of the Pauli \\(X\\)-gate? Solution: \\[ \\sigma_x= |0\\rangle\\langle 1| + |1\\rangle\\langle 0|. \\] The other Pauli matrices are also used as quantum gates, defining the Pauli Y-gate and Pauli Z-gate as follows: \\[ Y = \\sigma_y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix} \\] \\[ Z = \\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix} \\] ## Phase flip Recall that the global phase is not physically significant, and we are interested in changing the local phase. It is possible to define a phase flip gate performing the following operations: \\[ \\begin{aligned} |0\\rangle &amp;\\rightarrow |0\\rangle \\\\ |1\\rangle &amp;\\rightarrow e^{i\\phi} |1\\rangle \\end{aligned} \\] That is: \\[ P(\\phi) = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\phi} \\end{pmatrix}. \\] Two commonly used phase flip gates are: \\[ S = P\\left(\\frac{\\pi}{2}\\right) = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{\\frac{pi}{2}} \\end{pmatrix}= \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\end{pmatrix} \\] \\[ T = P\\left(\\frac{\\pi}{4}\\right) = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\frac{\\pi}{4}} \\end{pmatrix} \\] 3.3 CNOT gate CNOT is a two-qubit gate. Controlled operations play a key role in multi-qubit gates. The CNOT gate is the most commonly used two-qubit controlled operation. The state of the first qubit controls whether the second qubit will be flipped or not. The first qubit is referred to as the , and the second qubit is called the . The required transformation can be written in Dirac notation as follows: \\[ \\begin{eqnarray} |0\\rangle|0\\rangle &amp; \\rightarrow &amp; |0\\rangle|0\\rangle, \\\\ |0\\rangle|1\\rangle &amp; \\rightarrow &amp; |0\\rangle|1\\rangle, \\\\ |1\\rangle|0\\rangle &amp; \\rightarrow &amp; |1\\rangle|1\\rangle, \\\\ |1\\rangle|1\\rangle &amp; \\rightarrow &amp; |1\\rangle|0\\rangle. \\end{eqnarray} \\] Diagram: The matrix representation of the CNOT gate is: \\[ \\text{CNOT} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{pmatrix}. \\] The CNOT gate helps to create entangled states. Exercise 3.3 Show that the output state of the above circuit is the entangled state: \\[ \\frac{1}{\\sqrt{2}} \\big(|00\\rangle + |11\\rangle\\big). \\] Note that the action on separable states is as follows: \\[ (A \\otimes B)(|a\\rangle \\otimes |b\\rangle) = (A|a\\rangle) \\otimes (B|b\\rangle \\] Solution Exercise 3.4 Find the output Solution Exercise 3.5 Find the output Solution "],["deutschs.html", "Chapter 4 Deutsch’s", " Chapter 4 Deutsch’s David Deutach (Resource: Offical site) An early stage quantum algorithm that demonstrates the computational power of quantum computers is the algorithm invented by David Deutsch in 1985. Deutsch’s algorithm is based on quantum parallelism - in this context, the ability to evaluate a function \\(f(x)\\) at different \\(x\\) values simultaneously Consider functions from a one-bit domain \\(\\{0, 1\\}\\) to the same one-bit co-domain. There are two types of functions: constant and balanced. We are given a function: \\[f : \\{0,1\\} \\to \\{0,1\\}\\] Our goal is to determine whether f is: - Constant: \\(f(0) = f(1)\\) (same output for both inputs)? - Balanced: \\(f(0) \\neq f(1)\\) (different outputs for each input)? 4.0.0.1 Classical Solution, *Algorithm 1: Classical Algorithm for the Deutsch Problem (\\(n = 1\\))** Require: A black-box function \\(f : \\{0,1\\} \\rightarrow \\{0,1\\}\\) 1: Evaluate: Compute \\(f(0)\\) and \\(f(1)\\). 2: if \\(f(0) = f(1)\\) then 3: \\(~~~~~~\\) Output: “Constant” 4: else 5: \\(~~~~~~\\) Output: “Balanced” 6: end if Explanation Line 1: Input is a black-box function \\(f : \\{0,1\\} → \\{0,1\\}\\). Line 2: Evaluate the function at both possible inputs \\((0\\) and \\(1)\\). Line 3–6: Compare the outputs: If \\(f (0) = f(1)\\), then the function is constant. If \\(f (0)= f(1),\\) then the function is balanced. Classically, two queries to the function are necessary to determine this. Deutsch’s algorithm provides a quantum protocol to do this with a single query to the function Exercise 4.1 Let \\(x, y \\in \\{0, 1\\}\\) and \\(f : \\{0, 1\\} \\to \\{0, 1\\}\\). Show that the transformation: \\[ U_f |x, y\\rangle = |x, y \\oplus f(x)\\rangle \\] where \\(\\oplus\\) denotes addition modulo 2, is unitary. Solution The above transformation can be implemented in a quantum circuit by querying an oracle. Diagram:  This quantum circuit queries an oracle, and implements \\(U_f\\) Note that the transformation can be written as: \\[ U_f \\big(|+\\rangle , |0\\rangle\\big) = \\frac{1}{\\sqrt{2}} \\big(|0, f(0)\\rangle + |1, f(1)\\rangle\\big). \\] This contains information about both \\(f(0)\\) and \\(f(1)\\). That is like evaluating the function \\(f\\) at two different points in the domain. This is called Quantum parallelism. \\[ \\begin{eqnarray} U_f |x, -\\rangle &amp;=&amp; U_f \\left( |x\\rangle \\otimes \\left( \\frac{1}{\\sqrt{2}} |0\\rangle - \\frac{1}{\\sqrt{2}} |1\\rangle \\right) \\right)\\\\ &amp;=&amp; \\frac{1}{\\sqrt{2}} U_f (|x\\rangle \\otimes |0\\rangle) - \\frac{1}{\\sqrt{2}} U_f (|x\\rangle \\otimes |1\\rangle)\\\\ &amp;=&amp; \\frac{1}{\\sqrt{2}} |x, f(x)\\rangle - \\frac{1}{\\sqrt{2}} |x, 1 \\oplus f(x)\\rangle. \\end{eqnarray} \\] When \\(f(x) = 0\\): \\[ U_f |x, -\\rangle = \\frac{1}{\\sqrt{2}} |x, 0\\rangle - \\frac{1}{\\sqrt{2}} |x, 1\\rangle. \\] When \\(f(x) = 1\\): \\[ U_f |x, -\\rangle = -\\frac{1}{\\sqrt{2}} |x, 0\\rangle + \\frac{1}{\\sqrt{2}} |x, 1\\rangle. \\] Then we can summarize, \\[ U_f |x, -\\rangle = (-1)^{f(x)} |x, -\\rangle. \\] This is called Phase kickback. Deutsch’s algorithm is a black box algorithm, that uses quantum parallelism, and can be implemented efficiently using a quantum computer. Circuit implementation of Deutsch’s algorithm Given a function \\(f :\\ {0,1\\} \\rightarrow \\{0,1\\}\\), Deutsch’s algorithm determines whether \\(f\\) is constant or balanced, with a single query to the function \\[\\begin{eqnarray} |\\psi_0\\rangle &amp;=&amp; |00\\rangle\\\\ |\\psi_1\\rangle &amp;=&amp; |0\\rangle X|0\\rangle = |01\\rangle\\\\ |\\psi_2\\rangle &amp;=&amp; H|0\\rangle H|1\\rangle = |+\\rangle|−\\rangle\\\\ |\\psi_3\\rangle &amp;=&amp; U_f| +,−\\rangle\\\\ &amp;=&amp; U_f \\left( \\frac{1}{\\sqrt{2}} |0, -\\rangle + \\frac{1}{\\sqrt{2}} |1, -\\rangle \\right)\\\\ &amp;=&amp; \\frac{1}{\\sqrt{2}} U_f |0, -\\rangle + \\frac{1}{\\sqrt{2}} U_f |1, -\\rangle &amp;=&amp; \\end{eqnarray} \\] Then, \\[\\text{Phase kickback } U_f |x, -\\rangle = (-1)^{f(x)} |x, -\\rangle \\quad \\text{for } x \\in \\{0, 1\\}. \\] "],["quantum-computing-with-qiskit.html", "Chapter 5 Quantum Computing with Qiskit", " Chapter 5 Quantum Computing with Qiskit Qiskit is an open-source SDK for working with quantum computers at the level of extended quantum circuits, operators, and primitives. You can find more details in the following PDF file: View the PDF file Quantum Circuit Example Installing Qiskit and Required Packages Install Qiskit with Visualization Capabilities # Uncomment and run the following line to install Qiskit with visualization capabilities # !pip install qiskit[visualization] Check Qiskit Version import qiskit print(&quot;Qiskit version:&quot;, qiskit.__version__) ## Qiskit version: 1.4.1 Install Additional Required Packages # Uncomment the following lines to install other required packages # %pip install qiskit_aer # %pip install qiskit_ibm_runtime # %pip install matplotlib # %pip install qiskit-transpiler-service Setting Up the IBM Quantum Environment Create an account on IBM Quantum and retrieve your API token. Configuring the Environment from qiskit_ibm_runtime import QiskitRuntimeService # Initialize the service with your IBM Quantum token #service = QiskitRuntimeService( # channel=&quot;ibm_quantum&quot;, # token=&quot;YourActualTokenHere&quot; # Replace with your actual token #) service = QiskitRuntimeService(channel=&quot;ibm_quantum&quot;,token = &quot;33e6d21f4cc3ec730b896fc9aa77138a84bb48ed8bc6d24eff8bcbfffabd472e2869fce68f46978880d8ecf738531c002ce81809b9cf1ffd8995b00e0f9b24d0&quot;) # Access a specific backend backend = service.backend(name=&#39;ibm_brisbane&#39;) print(f&quot;Backend name: {backend.name}&quot;) ## Backend name: ibm_brisbane print(f&quot;Number of qubits: {backend.num_qubits}&quot;) ## Number of qubits: 127 #Importing QuantumCircuit from qiskit from qiskit import QuantumCircuit # Setting the number of qubits qc=QuantumCircuit(2) # Importing necessary packages to simulate results # Designing the circuit by adding Gates and Measurements qc.h(0) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D67F8DDED0&gt; qc.cx(0,1) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D6810512D0&gt; qc.measure_all() qc.draw(output=&#39;mpl&#39;) from qiskit import transpile from qiskit_aer import AerSimulator backend = AerSimulator() transpiled_qc = transpile(qc, backend) job = backend.run(transpiled_qc, shots=100) # Shots: Numbers of times the algorithm is run and measured counts = job.result().get_counts() print(counts) ## {&#39;11&#39;: 51, &#39;00&#39;: 49} # Plotting the results from the simulations from qiskit.visualization import plot_histogram plot_histogram(counts) Let’s try to make this in qiskit. ::: {.example #unnamed-chunk-18} ::: qc2=QuantumCircuit(2) qc2.x(0) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D6811FD030&gt; qc2.cx(0,1) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D6815EE770&gt; qc2.cx(1,0) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D682158EE0&gt; qc2.x(1) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D6815D75E0&gt; qc2.measure_all() qc2.draw(output=&#39;mpl&#39;) # Importing necessary packages to simulate results from qiskit import transpile from qiskit_aer import AerSimulator backend = AerSimulator() transpiled_qc2 = transpile(qc2, backend) job = backend.run(transpiled_qc2, shots=100) # Shots: Numbers of times the algorithm is run and measured counts = job.result().get_counts() print(counts) ## {&#39;00&#39;: 100} from qiskit.visualization import plot_histogram plot_histogram(counts) Example 5.1 qc3=QuantumCircuit(2) qc3.h(0) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D68160C730&gt; qc3.cx(0,1) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D681608430&gt; qc3.cx(1,0) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D68107CA90&gt; qc3.h(1) ## &lt;qiskit.circuit.instructionset.InstructionSet object at 0x000001D6815E6EF0&gt; qc3.measure_all() qc3.draw(output=&#39;mpl&#39;) # Importing necessary packages to simulate results from qiskit import transpile from qiskit_aer import AerSimulator backend = AerSimulator() transpiled_qc3 = transpile(qc3, backend) job = backend.run(transpiled_qc3, shots=100) # Shots: Numbers of times the algorithm is run and measured counts = job.result().get_counts() print(counts) ## {&#39;00&#39;: 100} from qiskit.visualization import plot_histogram plot_histogram(counts) "],["an-introduction-to-quantum-computing-and-the-deutsch-algorithm-a-mathematical-tour.html", "Chapter 6 An Introduction to Quantum Computing and the Deutsch Algorithm: A Mathematical Tour 6.1 The problem setting 6.2 Classical Solution 6.3 Quantum Computing: A High-Level Interpretation 6.4 The Quantum Twist – A New Way to Compute 6.5 Qubits vs. Bits 6.6 Mathematical Background and Notations 6.7 Outer Product and Projection Operators 6.8 Qubits: Data in Quantum Computing 6.9 Why Unit Vectors? 6.10 Bloch Sphere Representation of Qubit States 6.11 Quantum Gates: Processing Quantum Data 6.12 Universal Gate Sets 6.13 Phase Gate (S Gate) 6.14 Arbitrary Phase Shift: \\(R_z(\\theta)\\) Gate 6.15 \\(R_y(\\theta)\\) Gate 6.16 Pauli Gates: X, Y, and Z 6.17 Quantum Measurement: Capturing Information 6.18 Nature of Quantum Measurement 6.19 Formal Definition of Quantum Measurement 6.20 Example: Measurement in an Orthogonal Basis 6.21 Measurement in the \\(|+\\rangle\\) and \\(|-\\rangle\\) Basis 6.22 The Deutsch Problem 6.23 Deutsch Algorithm: Key Steps 6.24 Encoding Function Behavior via Phase Change 6.25 Apply Hadamard Transform (Interference) 6.26 Measurement 6.27 The Quantum Approach 6.28 Quantum Circuit for the Deutsch Algorithm 6.29 Multi-Qubit Systems, Quantum Entanglement, and Higher-Dimensional Extensions 6.30 Summary of Measurement Effects", " Chapter 6 An Introduction to Quantum Computing and the Deutsch Algorithm: A Mathematical Tour 6.1 The problem setting I order to design quantum algorithms we need to know how to execute functions on a quantum computer. In particular, we are interested in functions that take a (binary) number, and output a truth value (i.e., \\({0, 1}\\). That is, functions of the form \\(f : {0, 1}n → {0, 1}\\) Let us consider the following problem: There is a univariate function \\(f\\), defined over the binary alphabet \\(0,1,\\) with output range in the same alphabet \\(0,1\\). I.e., \\(f:\\{0,1\\}\\rightarrow \\{0,1\\}\\). We are given a function: \\[f : \\{0,1\\} \\to \\{0,1\\}\\] Our goal is to determine whether f is: - Constant: \\(f(0) = f(1)\\) (same output for both inputs)? - Balanced: \\(f(0) \\neq f(1)\\) (different outputs for each input)? 6.2 Classical Solution 6.2.0.1 Classical Algorithm for the Deutsch Problem (\\(n = 1\\)) Algorithm 1: Classical Algorithm for the Deutsch Problem (\\(n = 1\\)) Require: A black-box function \\(f : {0,1} → {0,1}\\) Evaluate: Compute \\(f(0)\\) and \\(f(1)\\). if \\(f(0) = f(1)\\) then Output: “Constant” else Output: “Balanced” end if Explanation Line 1: Input is a black-box function \\(f : {0,1} → {0,1}\\). Line 2: Evaluate the function at both possible inputs (0 and 1). Line 3–6: Compare the outputs: If \\(f(0) = f(1)\\), then the function is constant. If \\(f(0) \\neq f(1)\\), then the function is balanced. 6.2.0.2 Classical Algorithm for the Deutsch Problem (General Case) Suppose we are given a black-box function: \\[f : \\{0,1\\}ⁿ → \\{0,1\\}\\] The function \\(f\\) is promised to be either: - Constant: The output is the same for all inputs. \\(f(x) = f(y), \\forall x, y ∈ {0,1}ⁿ\\) - Balanced: The output is \\(0\\) for exactly half the inputs and \\(1\\) for the other half. \\[ | \\{x ∈ {0,1}ⁿ : f(x) = 0 \\} | = 2ⁿ⁻¹ \\] \\[ | \\{x ∈ {0,1}ⁿ : f(x) = 1 \\} | = 2ⁿ⁻¹ \\] Goal: Determine whether \\(f\\) is constant or balanced using the fewest possible queries (function evaluations). 6.3 Quantum Computing: A High-Level Interpretation 6.3.1 The Process of Computing Key Idea: Computing is about encoding information and transforming it under the rules of physics. 6.3.1.1 Classical Computing Data Encoding: Information stored as bits (0s and 1s). Processing: Logical gates manipulate bits according to classical physics. 6.3.1.2 Quantum Computing Data Encoding: Information stored in quantum states. Processing: Quantum operations transform qubits according to quantum mechanics. Information Extraction: Quantum measurement provides probabilistic (in general) information and collapses the quantum state. 6.4 The Quantum Twist – A New Way to Compute 6.5 Qubits vs. Bits Classical Bit: A classical bit is either 0 or 1. Qubit: A qubit is the quantum version of a bit and behaves differently. A qubit can exist in a state of superposition (a combination of 0 and 1). Qubits in a superposition state exhibit quantum interference. Multiple qubits can entangle, linking in special ways. Measurement affects the outcome! 6.5.1 Takeaway The challenge and goal is to harness quantum properties for efficient computation. Quantum computing isn’t just “faster,” it’s a fundamentally different way to compute! 6.6 Mathematical Background and Notations 6.6.1 Complex Hilbert Space \\(\\mathbb{C}^2\\) Let \\(\\mathbb{C}^2\\) be the set of all \\(2 \\times 1\\) complex vectors: \\[ \\mathbb{C}^2 = \\left\\{ \\begin{bmatrix} a \\\\ b \\end{bmatrix} : a, b \\in \\mathbb{C} \\right\\}. \\] Dirac Notation (Ket): \\[ |v\\rangle = \\begin{bmatrix} a \\\\ b \\end{bmatrix} .\\] Inner Product: The standard inner product on \\(\\mathbb{C}^2\\) is the function \\(\\langle \\cdot|\\cdot \\rangle :\\mathbb{C}^2\\to\\mathbb{C}\\) defined by: \\[ \\langle v|w\\rangle = \\overline{a}c + \\overline{b}d \\] for all \\(|v\\rangle = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\\) and \\(|w\\rangle = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\). Norm: \\(\\| |v\\rangle \\| = \\sqrt{\\langle v|v\\rangle }\\). 6.6.1.1 Properties and Terminologies Inner Product Properties: Conjugate linear in the first entry: \\[ \\langle v + \\lambda v&#39;|w\\rangle = \\langle v|w\\rangle + \\overline{\\lambda}\\langle v&#39;|w\\rangle .\\] Linear in the second entry: \\[ \\langle v|w + \\lambda w&#39;\\rangle = \\langle v|w\\rangle + \\lambda\\langle v|w&#39;\\rangle .\\] Orthogonality: Vectors \\(|v\\rangle , |w\\rangle ∈ \\mathbb{C}^2\\) are orthogonal if \\(\\langle v|w\\rangle = 0\\). Orthonormal Basis: A set of vectors \\(\\{|e_1\\rangle , |e_2\\rangle \\}\\) is an orthonormal basis if \\[ \\langle e_i|e_j\\rangle = δ_{ij}= \\begin{cases} 1 &amp; \\text{ if } i \\neq j\\\\ 0 &amp; \\text{ if } i = j\\ \\end{cases}.\\] For any \\(|v\\rangle ∈ \\mathbb{C}^2\\), \\[ |v\\rangle = a|e_1\\rangle + b|e_2\\rangle , \\] for some \\(a,b \\in \\mathbb{C}^2\\) and moreover \\(a = \\langle e_1|v\\rangle\\) and \\(b = \\langle e_2|v\\rangle\\). Example 6.1 (Orthonormal Basis) Standard Basis: \\(|0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\), \\(|1\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\). Hadamard Basis: \\(|+\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle )\\), \\(|−\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle − |1\\rangle )\\). Consider \\(|w\\rangle = \\begin{bmatrix}1 \\\\ 2 \\end{bmatrix}\\), and now if \\(\\langle +|w\\rangle = x\\), \\(\\langle −|w\\rangle = y\\), then \\[ |w\\rangle = x|+\\rangle + y|−\\rangle .\\] 6.6.1.2 Matrices as Linear Operators A \\(2 \\times 2\\) complex matrix \\(A\\) acts on \\(\\mathbb{C}^2\\) as a linear operator via multiplication: \\[ A|v\\rangle = |w\\rangle .\\] Properties: Linearity: \\(A(|v\\rangle + |w\\rangle ) = A|v\\rangle + A|w\\rangle\\), \\(A(c|v\\rangle ) = cA|v\\rangle\\) (for scalar \\(c\\)). Hermitian Adjoint (Conjugate Transpose): Given \\[ A = \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix} ,\\] \\[ A^\\dagger = \\begin{bmatrix} \\overline{a} &amp; \\overline{c} \\\\ \\overline{b} &amp; \\overline{d} \\end{bmatrix}. \\] 6.6.1.3 Types of Matrices Considered in Quantum Computing Self-Adjoint Matrix: \\(H^\\dagger = H\\). Example: \\(H = \\begin{bmatrix} 2 &amp; i \\\\ -i &amp; 3 \\end{bmatrix}\\). Unitary Matrix: \\(U^\\dagger U = UU^\\dagger = I\\). Example: \\(U = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; 1 \\\\ -1 &amp; 1 \\end{bmatrix}\\), \\(U^\\dagger = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; -1 \\\\ 1 &amp; 1 \\end{bmatrix}\\).Then, \\[U U^\\dagger= \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; 1 \\\\ -1 &amp; 1 \\end{bmatrix} \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; -1 \\\\ 1 &amp; 1 \\end{bmatrix}=I\\] Projection Matrix: \\(P^2 = P\\) and \\(P^\\dagger = P\\). Example: \\(P = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}\\). Then, \\[ P^2=\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}=P \\] and, \\[ P^\\dagger=\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}=P \\] Thus, \\(P\\) is projection 6.6.2 Linear Functionals and Bra Notation Definition 6.1 A linear functional is a map \\(f : \\mathbb{C}^2 → \\mathbb{C}\\) satisfying: \\[ f(α|v\\rangle + |w\\rangle ) = αf(|v\\rangle ) + f(|w\\rangle ). \\] Definition 6.2 \\(\\{f : \\mathbb{C}^2 →\\mathbb{C}: f is linear\\}\\) is called the dual space of \\(\\mathbb{C}^2\\). Bra Notation: Each \\(|w\\rangle ∈ \\mathbb{C}^2\\) has an associated bra \\(\\langle w|\\), defined as: \\(|v\\rangle → \\langle w|v\\rangle\\) for all \\(|v\\rangle ∈ \\mathbb{C}^2\\). Example 6.2 If \\(|+\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\), its corresponding bra is: \\[ \\langle +| = \\frac{1}{\\sqrt{2}} (1, 1) .\\] 6.7 Outer Product and Projection Operators Outer Product: Given \\(|ϕ\\rangle , |ψ\\rangle ∈ \\mathbb{C}^2\\), the outer product \\(|ϕ\\rangle \\langle ψ|\\) is the operator defined by: \\[ (|ϕ\\rangle \\langle ψ|)|v\\rangle = \\langle ψ|v\\rangle |ϕ\\rangle.\\] In matrix form, if \\(|ϕ\\rangle = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\\), \\(|ψ\\rangle = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\): \\[ |ϕ\\rangle \\langle ψ| = \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\begin{bmatrix} \\overline{c} &amp; \\overline{d} \\end{bmatrix} = \\begin{bmatrix} a\\overline{c} &amp; a\\overline{d} \\\\ b\\overline{c} &amp; b\\overline{d} \\end{bmatrix} .\\] Projection: If \\(|ϕ\\rangle = |ψ\\rangle\\), we get a projection: \\(P = |ψ\\rangle \\langle ψ|\\), satisfying \\(P^2 = P\\). ````{example} For the plus state \\(|+\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\): \\(|+\\rangle \\langle +| = \\frac{1}{2} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix}\\). Outer Product: When taking the outer product of a ket with the bra of itself (i.e., \\(|\\phi\\rangle = |\\psi\\rangle\\)), the result is a projection on the space spanned by the vector. \\[ P = |\\psi\\rangle \\langle \\psi|\\text{ This satisfies: } P^2 = P \\] Example 6.3 For \\(|+\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\), \\[ |+\\rangle \\langle +| = \\frac{1}{2} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix} \\] 6.7.1 Takeaways: Outer products generalize linear maps of rank one. Special case: \\(|\\psi\\rangle \\langle \\psi|\\) defines a one-dimensional projection operator. Projections play a fundamental role in the mathematical formulation of quantum measurements. 6.8 Qubits: Data in Quantum Computing 6.8.1 Intuitive Notion: Classical Computing: Bits encode information as \\(0\\) or \\(1\\). Quantum Computing: Qubits encode information as a superposition of \\(0\\) and \\(1\\), enabling the processing of multiple possibilities simultaneously. 6.8.2 Mathematical Definition: A qubit is a unit vector in \\(\\mathbb{C}^2\\): \\[ |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle, \\quad \\alpha, \\beta \\in \\mathbb{C}, \\quad |\\alpha|^2 + |\\beta|^2 = 1 \\] Where: - \\(|0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\) - \\(|1\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\) 6.9 Why Unit Vectors? 6.9.1 A Probabilistic System: A qubit represents a superposition of classical outcomes. Measurement outcomes are probabilistic, not deterministic. 6.9.2 Normalization Condition: Probabilities must sum to \\(1\\). For a qubit: \\[ |\\alpha|^2 + |\\beta|^2 = 1 \\] 6.9.3 The Born Rule: Upon measurement: \\[(\\text{Pr}(\\text{Outcome } |0\\rangle) = |\\alpha|^2\\)~,~ (\\text{Pr}(\\text{Outcome } |1\\rangle) = |\\beta|^2\\] The qubit collapses to the observed basis state with these probabilitie 6.10 Bloch Sphere Representation of Qubit States A general single-qubit state is a unit vector in \\(\\mathbb{C}^2\\): \\[ |ψ\\rangle = α|0\\rangle+β|\\rangle\\], where \\(α,β ∈\\mathbb{C}, |α|^2 +|β|^2 = 1.\\) Any such state can be written in the form: \\[ |\\psi\\rangle = \\cos\\frac{\\theta}{2} |0\\rangle + e^{i\\phi} \\sin\\frac{\\theta}{2} |1\\rangle \\] Where: \\(\\theta \\in [0, \\pi]\\): Weight of \\(|0\\rangle\\) and \\(|1\\rangle\\) \\(\\phi \\in [0, 2\\pi)\\): Relative phase between \\(|0\\rangle\\) and \\(|1\\rangle\\) The angles \\((θ,ϕ)\\) define a unique point on the unit sphere in \\(\\mathbb{R}^3.\\) The state \\(|\\psi\\rangle\\) maps to a point \\(\\mathbf{r}\\) on the unit sphere: \\[ \\mathbf{r} = (\\langle \\sigma_x \\rangle, \\langle \\sigma_y \\rangle, \\langle \\sigma_z \\rangle) \\] Where: \\(\\langle \\sigma_x \\rangle = \\sin\\theta \\cos\\phi\\) \\(\\langle \\sigma_y \\rangle = \\sin\\theta \\sin\\phi\\) \\(\\langle \\sigma_z \\rangle = \\cos\\theta\\) This defines a one-to-one correspondence between quantum states (up to a global phase) (\\(e^{i\\gamma}|\\psi\\)) and points on the unit sphere. Remark. The global phase does not change the Bloch sphere representation. That is, states differing by a global phase represent the same physical qubit state. source: Wikipedia 6.11 Quantum Gates: Processing Quantum Data 6.11.1 Classical vs. Quantum: Classical Gates: Perform logical operations (e.g., AND, OR, NOT). Quantum Gates: Perform transformations on qubits using unitary operations. 6.11.2 Why Unitary Matrices? Reversible: Quantum mechanics laws are reversible. Norm-Preserving: Probabilities must sum to \\(1\\). Definition 6.3 A quantum gate is a \\(2 \\times 2\\) unitary matrix \\(U\\) satisfying: \\[ U^\\dagger U = I \\] Here’s the updated table with two columns, focusing on the Classical NOT Gate and Quantum Phase Gate (\\(R_\\phi\\)): Classical NOT Gate Quantum Phase Gate (\\(R_\\phi\\)) Input: Matrix: \\(\\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\\) Matrix: \\(\\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\phi} \\end{bmatrix}\\) Action: \\(\\text{NOT}(|0\\rangle) = |1\\rangle\\), \\(\\text{NOT}(|1\\rangle) = |0\\rangle\\) Action: \\(R_\\phi (\\alpha|0\\rangle + \\beta|1\\rangle) = \\alpha|0\\rangle + \\beta e^{i\\phi} |1\\rangle\\) 6.11.3 Classical NOT Gate: Matrix: \\[ \\text{NOT} = \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\] Action: - \\(\\text{NOT}(|0\\rangle) = |1\\rangle\\) - \\(\\text{NOT}(|1\\rangle) = |0\\rangle\\) 6.11.4 Quantum Phase Gate (\\(R_\\phi\\)): Matrix: \\[ R_\\phi = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\phi} \\end{bmatrix} \\] Action: \\[ R_\\phi (\\alpha|0\\rangle + \\beta|1\\rangle) = \\alpha|0\\rangle + \\beta e^{i\\phi} |1\\rangle \\] 6.12 Universal Gate Sets 6.12.1 Classical Universal Gates: Definition: A set of gates is universal if it can implement any Boolean function. Example: AND, OR, NOT (or NAND alone). 6.12.2 Quantum Universal Gates: Definition: A set of quantum gates is universal if any unitary operation can be approximated to arbitrary accuracy. 6.12.3 Why is Universality Important? Just like classical computing can be built from a small set of universal gates, quantum computing relies on universal gates to perform any computation. The ability to approximate any unitary transformation is crucial for building general-purpose quantum computers 6.12.4 Examples (Single-Qubit Case): \\(\\{H, S, X\\}\\): Hadamard, Phase, Bit flip \\(\\{H, R_z(\\theta), X\\}\\): Hadamard, Z-axis rotation, Bit flip \\(\\{H, R_y(\\theta)\\}\\): Hadamard, Y-axis rotation \\(\\{X, Y, Z, H\\}\\): Pauli-X, Y, Z, Hadamard \\(\\{H, T, X\\}\\): Hadamard, T gate, Bit flip Later, we disscued each gate separetely. 6.12.5 Hadamard Gate The Hadamard gate creates superposition by transforming basis states. Matrix Representation: \\[ H = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{pmatrix} \\] Action on Basis States: \\[ H|0\\rangle = \\frac{|0\\rangle + |1\\rangle }{\\sqrt{2}}, \\quad H|1\\rangle = \\frac{|0\\rangle - |1\\rangle }{\\sqrt{2}} \\] 6.13 Phase Gate (S Gate) The phase gate introduces a phase shift of \\(\\pi/2\\). Matrix Representation: \\[ S = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\end{pmatrix} \\] Action on Basis States: \\[ S|0\\rangle = |0\\rangle , \\quad S|1\\rangle = i|1\\rangle \\] 6.14 Arbitrary Phase Shift: \\(R_z(\\theta)\\) Gate This gate applies an arbitrary phase rotation around the z-axis. Matrix Representation: \\[ R_z(\\theta) = \\begin{pmatrix} e^{-i\\theta/2} &amp; 0 \\\\ 0 &amp; e^{i\\theta/2} \\end{pmatrix} \\] Action on Basis States: \\[ R_z(\\theta)|0\\rangle = e^{-i\\theta/2}|0\\rangle \\] \\[ R_z(\\theta)|1\\rangle = e^{i\\theta/2}|1\\rangle \\] 6.15 \\(R_y(\\theta)\\) Gate The \\(R_y(\\theta)\\) gate represents a rotation by an angle \\(\\theta\\) around the y-axis on the Bloch sphere. Matrix Representation: \\[ R_y(\\theta) = \\begin{pmatrix} \\cos(\\theta/2) &amp; -\\sin(\\theta/2) \\\\ \\sin(\\theta/2) &amp; \\cos(\\theta/2) \\end{pmatrix} \\] Action on Basis States: \\[ R_y(\\theta)|0\\rangle = \\cos(\\theta/2)|0\\rangle + \\sin(\\theta/2)|1\\rangle \\] \\[ R_y(\\theta)|1\\rangle = -\\sin(\\theta/2)|0\\rangle + \\cos(\\theta/2)|1\\rangle \\] 6.16 Pauli Gates: X, Y, and Z 6.16.1 Pauli-X (Bit-Flip Gate) Swaps \\(|0\\rangle\\) and \\(|1\\rangle\\), analogous to a classical NOT gate. Matrix Representation: \\[ X = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\] Action on Basis States: \\[ X|0\\rangle = |1\\rangle , \\quad X|1\\rangle = |0\\rangle \\] 6.16.2 Pauli-Y Gate Combines bit-flip and phase-flip operations. Matrix Representation: \\[ Y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix} \\] Action on Basis States: \\[ Y|0\\rangle = i|1\\rangle , \\quad Y|1\\rangle = -i|0\\rangle \\] 6.16.3 Pauli-Z (Phase-Flip Gate) Leaves \\(|0\\rangle\\) unchanged but flips the phase of \\(|1\\rangle\\). Matrix Representation: \\[ Z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix} \\] Action on Basis States: \\[ Z|0\\rangle = |0\\rangle , \\quad Z|1\\rangle = -|1\\rangle \\] 6.17 Quantum Measurement: Capturing Information 6.17.1 Key Idea In quantum computing, measurement extracts information from a quantum state, but the process is probabilistic and alters the state. Classical measurement gives a deterministic outcome without changing the system. Quantum measurement is inherently probabilistic and collapses the quantum state to a definite outcome. 6.18 Nature of Quantum Measurement 6.18.1 Physical Interpretation Measurement corresponds to observing a physical property (e.g., spin direction, polarization). Before measurement, the system exists in a superposition of states. Measurement collapses the superposition to one of the possible outcomes. 6.18.2 Mathematical Representation Measurement is modeled using projection operators \\(P_i\\). Each \\(P_i\\) corresponds to a possible measurement outcome. Probabilities and post-measurement states follow from these operators. 6.19 Formal Definition of Quantum Measurement Let \\(|ψ\\rangle\\) be a quantum state and \\(\\{P_i\\}\\) a set of projection operators: Probability of Outcome \\(i\\): \\[ p(i) = \\langle ψ|P_i|ψ\\rangle \\] Post-Measurement State (if Outcome \\(i\\) Occurs): \\[ |ψ_i\\rangle = \\frac{P_i |ψ\\rangle }{\\sqrt{p(i)}} \\] Projection Operators: \\[ P_i = |ϕ_i\\rangle \\langle ϕ_i|, \\quad \\sum_i P_i = I \\] 6.20 Example: Measurement in an Orthogonal Basis 6.20.1 Initial State: \\[ |ψ\\rangle = α|0\\rangle + β|1\\rangle \\] 6.20.2 Measurement in Computational Basis (\\(|0\\rangle , |1\\rangle\\)): Projection Operators: \\[ P_0 = |0\\rangle \\langle 0|, \\quad P_1 = |1\\rangle \\langle 1| \\] Probability of Measuring \\(|0\\rangle\\): \\[ p(0) = |α|^2 \\] Post-Measurement State: \\(|0\\rangle\\) Probability of Measuring \\(|1\\rangle\\): \\[ p(1) = |β|^2 \\] Post-Measurement State: \\(|1\\rangle\\) 6.21 Measurement in the \\(|+\\rangle\\) and \\(|-\\rangle\\) Basis 6.21.1 Given State: \\[ |ψ\\rangle = \\sqrt{0.75}|0\\rangle + \\sqrt{0.25}|1\\rangle \\] 6.21.2 Overlaps: \\(\\langle+|ψ\\rangle = \\frac{1}{\\sqrt{2}}(\\sqrt{0.75} + \\sqrt{0.25}) \\approx 0.96\\) \\(\\langle-|ψ\\rangle = \\frac{1}{\\sqrt{2}}(\\sqrt{0.75} - \\sqrt{0.25}) \\approx 0.25\\) 6.21.3 Measurement Probabilities: \\(P(|+\\rangle ) = |\\langle+|ψ\\rangle |^2 \\approx 0.93\\) \\(P(|-\\rangle ) = |\\langle-|ψ\\rangle |^2 \\approx 0.07\\) 6.22 The Deutsch Problem 6.22.1 Problem: Given: A function \\(f : \\{0,1\\} \\to \\{0,1\\}\\). Task: Determine if \\(f\\) is constant or balanced. 6.22.2 Classical Approach: Requires two function evaluations in the worst case. 6.22.3 Quantum Goal: Use quantum computing to determine this in a single function call! 6.23 Deutsch Algorithm: Key Steps Input: Two qubits: First qubit: \\(|x\\rangle\\) (input qubit). Second qubit: \\(|y\\rangle\\) (auxiliary qubit, used for function evaluation). Prepare a Superposition: Apply Hadamard gates to each qubit to create a superposition: First qubit: \\(H |0\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\). Second qubit: \\(H |1\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)\\). Apply the Oracle \\(U_f\\): The oracle applies the transformation: \\[ U_f |x, y\\rangle = |x, y \\oplus f(x)\\rangle \\] This encodes \\(f(x)\\) in the second qubit. 6.24 Encoding Function Behavior via Phase Change Rewrite the second qubit in terms of a phase: \\[ U_f (H \\otimes H)|0,1\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + (-1)^{f(1) \\oplus f(0)} |1\\rangle)|-\\rangle \\] The first qubit now contains information about \\(f(x)\\). 6.25 Apply Hadamard Transform (Interference) Applying Hadamard again on the first qubit results in: \\[ H \\frac{1}{\\sqrt{2}}(|0\\rangle + (-1)^{f(1) \\oplus f(0)} |1\\rangle) \\] This step extracts global information about \\(f(x)\\). 6.26 Measurement Measure the first qubit: \\(|0\\rangle\\): \\(f(x)\\) is constant. \\(|1\\rangle\\): \\(f(x)\\) is balanced. The second qubit is ignored in the measurement. 6.27 The Quantum Approach Key Idea: Encode inputs into qubits. Apply a quantum oracle representing \\(f(x)\\). Quantum Advantage: By preparing a superposition of inputs, evaluate the function on both inputs in a single query. Interference allows extraction of the relevant information. Measurement at the end gives the answer deterministically. 6.28 Quantum Circuit for the Deutsch Algorithm 6.28.1 Explanation: Apply Hadamard gates to create superposition. Use the oracle \\(U_f\\) to introduce a phase based on \\(f(x)\\). Perform a final Hadamard to extract interference information. Measure the first qubit to determine whether \\(f\\) is constant or balanced. 6.29 Multi-Qubit Systems, Quantum Entanglement, and Higher-Dimensional Extensions 6.29.1 Two-Qubit State Space A single qubit state is a unit vector in \\(\\mathbb{C}^2\\). Two-qubit states reside in \\(\\mathbb{C}^2 \\otimes \\mathbb{C}^2\\) (denoted as \\(\\mathbb{C}^4\\)). 6.29.2 Basis Elements: \\(|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\). 6.29.3 Entanglement and Physical Interpretation Entanglement: A state \\(|\\psi\\rangle\\) is entangled if it cannot be written as a tensor product of two single-qubit states: \\[ |\\psi\\rangle \\neq |\\psi_1\\rangle \\otimes |\\psi_2\\rangle \\] Example of an entangled state: \\[ |\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\] Example of a non-entangled state: \\[ |\\psi\\rangle = |0\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\] Physical Interpretation: Entangled states exhibit correlations that cannot be explained classically. Measurement outcomes of entangled qubits are correlated, regardless of distance. 6.29.4 Measurement Effects 6.29.4.1 Entangled State: Example: \\(|\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\\). Measurement on the first qubit: If \\(|0\\rangle\\): Collapse to \\(|00\\rangle\\). If \\(|1\\rangle\\): Collapse to \\(|11\\rangle\\). Conclusion: Measurement on one qubit determines the state of the other. 6.29.4.2 Separable State: Example: \\(|\\psi\\rangle = |0\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\). Measurement on the first qubit: The first qubit is always \\(|0\\rangle\\). Measurement on the second qubit: \\(|0\\rangle\\) or \\(|1\\rangle\\) with equal probability. 6.30 Summary of Measurement Effects 6.30.1 Entangled State: Measurement on one qubit affects the state of the other. Shows strong correlations. 6.30.2 Separable State: Measurement on one qubit does not affect the other. No correlations between outcomes. 6.30.3 Physical Interpretation: Entanglement exhibits “action at a distance”. Separable states behave independently. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
