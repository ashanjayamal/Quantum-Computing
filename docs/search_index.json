[["index.html", "Introduction to Quantum Computing Chapter 1 Introduction 1.1 The problem setting", " Introduction to Quantum Computing Ashan Jayamal 2025-03-02 Chapter 1 Introduction 1.1 The problem setting I order to design quantum algorithms we need to know how to execute functions on a quantum computer. In particular, we are interested in functions that take a (binary) number, and output a truth value (i.e., \\({0, 1}\\). That is, functions of the form \\(f : {0, 1}n → {0, 1}\\) Let us consider the following problem: There is a univariate function \\(f\\), defined over the binary alphabet \\(0,1,\\) with output range in the same alphabet \\(0,1\\). I.e., \\(f:\\{0,1\\}\\rightarrow \\{0,1\\}\\). We are given a function: \\[f : \\{0,1\\} \\to \\{0,1\\}\\] Our goal is to determine whether \\(f\\) is: - Constant: \\(f (0) = f(1)\\) (same output for both inputs) - Balanced: $f (0)= f(1) $(different outputs for each input) "],["an-introduction-to-quantum-computing-and-the-deutsch-algorithm-a-mathematical-tour.html", "Chapter 2 An Introduction to Quantum Computing and the Deutsch Algorithm: A Mathematical Tour 2.1 Simple Problem 2.2 Classical Solution 2.3 Quantum Computing: A High-Level Interpretation 2.4 The Quantum Twist – A New Way to Compute 2.5 Qubits vs. Bits 2.6 Mathematical Background and Notations 2.7 Linear Functionals and Bra Notation 2.8 Outer Product and Projection Operators 2.9 Outer Product and Projection Operators 2.10 Back to Quantum Computing… 2.11 Qubits: Data in Quantum Computing 2.12 Why Unit Vectors? 2.13 Bloch Sphere Representation of Qubit States 2.14 Quantum Gates: Processing Quantum Data 2.15 Classical and Quantum Gates 2.16 Universal Gate Sets 2.17 Quantum Computing Notes 2.18 Hadamard Gate 2.19 Phase Gate (S Gate) 2.20 Arbitrary Phase Shift: \\(R_z(\\theta)\\) Gate 2.21 \\(R_y(\\theta)\\) Gate 2.22 Pauli Gates: X, Y, and Z 2.23 Quantum Measurement: Capturing Information 2.24 Nature of Quantum Measurement 2.25 Formal Definition of Quantum Measurement 2.26 Example: Measurement in an Orthogonal Basis 2.27 Measurement in the \\(|+⟩\\) and \\(|-⟩\\) Basis 2.28 The Deutsch Problem 2.29 Deutsch Algorithm: Key Steps 2.30 Encoding Function Behavior via Phase Change 2.31 Apply Hadamard Transform (Interference) 2.32 Measurement 2.33 The Quantum Approach 2.34 Quantum Circuit for the Deutsch Algorithm 2.35 Multi-Qubit Systems, Quantum Entanglement, and Higher-Dimensional Extensions 2.36 Summary of Measurement Effects", " Chapter 2 An Introduction to Quantum Computing and the Deutsch Algorithm: A Mathematical Tour 2.1 Simple Problem We are given a function: \\[f : \\{0,1\\} \\to \\{0,1\\}\\] Our goal is to determine whether f is: - Constant: \\(f(0) = f(1)\\) (same output for both inputs)? - Balanced: \\(f(0) \\neq f(1)\\) (different outputs for each input)? 2.2 Classical Solution 2.2.0.1 Classical Algorithm for the Deutsch Problem (\\(n = 1\\)) Algorithm 1: Classical Algorithm for the Deutsch Problem (\\(n = 1\\)) Require: A black-box function \\(f : {0,1} → {0,1}\\) Evaluate: Compute \\(f(0)\\) and \\(f(1)\\). if \\(f(0) = f(1)\\) then Output: “Constant” else Output: “Balanced” end if Explanation Line 1: Input is a black-box function \\(f : {0,1} → {0,1}\\). Line 2: Evaluate the function at both possible inputs (0 and 1). Line 3–6: Compare the outputs: If \\(f(0) = f(1)\\), then the function is constant. If \\(f(0) \\neq f(1)\\), then the function is balanced. 2.2.0.2 Classical Algorithm for the Deutsch Problem (General Case) Suppose we are given a black-box function: \\[f : \\{0,1\\}ⁿ → \\{0,1\\}\\] The function \\(f\\) is promised to be either: - Constant: The output is the same for all inputs. \\(f(x) = f(y), \\forall x, y ∈ {0,1}ⁿ\\) - Balanced: The output is \\(0\\) for exactly half the inputs and \\(1\\) for the other half. \\[ | \\{x ∈ {0,1}ⁿ : f(x) = 0 \\} | = 2ⁿ⁻¹ \\] \\[ | \\{x ∈ {0,1}ⁿ : f(x) = 1 \\} | = 2ⁿ⁻¹ \\] Goal: Determine whether \\(f\\) is constant or balanced using the fewest possible queries (function evaluations). 2.3 Quantum Computing: A High-Level Interpretation 2.3.1 The Process of Computing Key Idea: Computing is about encoding information and transforming it under the rules of physics. 2.3.1.1 Classical Computing Data Encoding: Information stored as bits (0s and 1s). Processing: Logical gates manipulate bits according to classical physics. 2.3.1.2 Quantum Computing Data Encoding: Information stored in quantum states. Processing: Quantum operations transform qubits according to quantum mechanics. Information Extraction: Quantum measurement provides probabilistic (in general) information and collapses the quantum state. 2.4 The Quantum Twist – A New Way to Compute 2.5 Qubits vs. Bits Classical Bit: A classical bit is either 0 or 1. Qubit: A qubit is the quantum version of a bit and behaves differently. A qubit can exist in a state of superposition (a combination of 0 and 1). Qubits in a superposition state exhibit quantum interference. Multiple qubits can entangle, linking in special ways. Measurement affects the outcome! 2.5.1 Takeaway The challenge and goal is to harness quantum properties for efficient computation. Quantum computing isn’t just “faster,” it’s a fundamentally different way to compute! 2.6 Mathematical Background and Notations 2.6.1 Complex Hilbert Space \\(\\mathbb{C}^2\\) Let \\(\\mathbb{C}^2\\) be the set of all \\(2 \\times 1\\) complex vectors: \\[ \\mathbb{C}^2 = \\left\\{ \\begin{bmatrix} a \\\\ b \\end{bmatrix} : a, b \\in \\mathbb{C} \\right\\}. \\] Dirac Notation (Ket): \\[ |v⟩ = \\begin{bmatrix} a \\\\ b \\end{bmatrix} .\\] Inner Product: The standard inner product on \\(\\mathbb{C}^2\\) is the function \\(⟨\\cdot|\\cdot ⟩:\\mathbb{C}^2\\to\\mathbb{C}\\) defined by: \\[ ⟨v|w⟩ = \\overline{a}c + \\overline{b}d \\] for all \\(|v⟩ = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\\) and \\(|w⟩ = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\). Norm: \\(\\| |v⟩ \\| = \\sqrt{⟨v|v⟩}\\). 2.6.1.1 Properties and Terminologies Inner Product Properties: Conjugate linear in the first entry: \\[ ⟨v + \\lambda v&#39;|w⟩ = ⟨v|w⟩ + \\overline{\\lambda}⟨v&#39;|w⟩ .\\] Linear in the second entry: \\[ ⟨v|w + \\lambda w&#39;⟩ = ⟨v|w⟩ + \\lambda⟨v|w&#39;⟩ .\\] Orthogonality: Vectors \\(|v⟩, |w⟩ ∈ \\mathbb{C}^2\\) are orthogonal if \\(⟨v|w⟩ = 0\\). Orthonormal Basis: A set of vectors \\(\\{|e_1⟩, |e_2⟩\\}\\) is an orthonormal basis if \\(⟨e_i|e_j⟩ = δ_{ij}\\). For any \\(|v⟩ ∈ \\mathbb{C}^2\\), \\[ |v⟩ = a|e_1⟩ + b|e_2⟩, \\] for some \\(a,b \\in \\mathbb{C}^2\\) and moreover \\(a = ⟨e_1|v⟩\\) and \\(b = ⟨e_2|v⟩\\). Example 2.1 (Orthonormal Basis) Standard Basis: \\(|0⟩ = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\), \\(|1⟩ = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\). Hadamard Basis: \\(|+⟩ = \\frac{1}{\\sqrt{2}}(|0⟩ + |1⟩)\\), \\(|−⟩ = \\frac{1}{\\sqrt{2}}(|0⟩ − |1⟩)\\). Consider \\(|w⟩ = \\begin{bmatrix}1 \\\\ 2 \\end{bmatrix}\\), and now if \\(⟨+|w⟩ = x\\), \\(⟨−|w⟩ = y\\), then \\[ |w⟩ = x|+⟩ + y|−⟩ .\\] 2.6.2 Matrices as Linear Operators A \\(2 \\times 2\\) complex matrix \\(A\\) acts on \\(\\mathbb{C}^2\\) as a linear operator via multiplication: \\(A|v⟩ = |w⟩\\). Properties: Linearity: \\(A(|v⟩ + |w⟩) = A|v⟩ + A|w⟩\\), \\(A(c|v⟩) = cA|v⟩\\) (for scalar \\(c\\)). Hermitian Adjoint (Conjugate Transpose): Given \\(A = \\begin{bmatrix} a &amp; b \\\\ c &amp; d \\end{bmatrix}\\), \\(A^\\dagger = \\begin{bmatrix} \\overline{a} &amp; \\overline{c} \\\\ \\overline{b} &amp; \\overline{d} \\end{bmatrix}\\). 2.6.3 Types of Matrices Considered in Quantum Computing Self-Adjoint Matrix: \\(H^\\dagger = H\\). Example: \\(H = \\begin{bmatrix} 2 &amp; i \\\\ -i &amp; 3 \\end{bmatrix}\\). Unitary Matrix: \\(U^\\dagger U = UU^\\dagger = I\\). Example: \\(U = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; 1 \\\\ -1 &amp; 1 \\end{bmatrix}\\), \\(U^\\dagger = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 &amp; -1 \\\\ 1 &amp; 1 \\end{bmatrix}\\). Projection Matrix: \\(P^2 = P\\) and \\(P^\\dagger = P\\). Example: \\(P = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 0 \\end{bmatrix}\\). 2.7 Linear Functionals and Bra Notation Definition: A linear functional is a map \\(f : \\mathbb{C}^2 → \\mathbb{C}\\) satisfying: \\(f(α|v⟩ + |w⟩) = αf(|v⟩) + f(|w⟩)\\). Bra Notation: Each \\(|w⟩ ∈ \\mathbb{C}^2\\) has an associated bra \\(⟨w|\\), defined as: \\(|v⟩ → ⟨w|v⟩\\) for all \\(|v⟩ ∈ \\mathbb{C}^2\\). Example: If \\(|+⟩ = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\), its corresponding bra is: \\(⟨+| = \\frac{1}{\\sqrt{2}} (1, 1)\\). 2.8 Outer Product and Projection Operators Outer Product: Given \\(|ϕ⟩, |ψ⟩ ∈ \\mathbb{C}^2\\), the outer product \\(|ϕ⟩⟨ψ|\\) is the operator defined by: \\((|ϕ⟩⟨ψ|)|v⟩ = ⟨ψ|v⟩|ϕ⟩\\). In matrix form, if \\(|ϕ⟩ = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\\), \\(|ψ⟩ = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\): \\(|ϕ⟩⟨ψ| = \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\begin{bmatrix} \\overline{c} &amp; \\overline{d} \\end{bmatrix} = \\begin{bmatrix} a\\overline{c} &amp; a\\overline{d} \\\\ b\\overline{c} &amp; b\\overline{d} \\end{bmatrix}\\). Projection: If \\(|ϕ⟩ = |ψ⟩\\), we get a projection: \\(P = |ψ⟩⟨ψ|\\), satisfying \\(P^2 = P\\). Example: For the plus state \\(|+⟩ = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\): \\(|+⟩⟨+| = \\frac{1}{2} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix}\\). 2.9 Outer Product and Projection Operators 2.9.1 Key Points: Outer Product: When taking the outer product of a ket with the bra of itself (i.e., \\(|\\phi\\rangle = |\\psi\\rangle\\)), the result is a projection on the space spanned by the vector. \\[ P = |\\psi\\rangle \\langle \\psi| \\] This satisfies: \\[ P^2 = P \\] Example: For \\(|+\\rangle = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\), \\[ |+\\rangle \\langle +| = \\frac{1}{2} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix} \\] 2.9.2 Takeaways: Outer products generalize linear maps of rank one. Special case: \\(|\\psi\\rangle \\langle \\psi|\\) defines a one-dimensional projection operator. Projections play a fundamental role in the mathematical formulation of quantum measurements. 2.10 Back to Quantum Computing… 2.11 Qubits: Data in Quantum Computing 2.11.1 Intuitive Notion: Classical Computing: Bits encode information as \\(0\\) or \\(1\\). Quantum Computing: Qubits encode information as a superposition of \\(0\\) and \\(1\\), enabling the processing of multiple possibilities simultaneously. 2.11.2 Mathematical Definition: A qubit is a unit vector in \\(\\mathbb{C}^2\\): \\[ |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle, \\quad \\alpha, \\beta \\in \\mathbb{C}, \\quad |\\alpha|^2 + |\\beta|^2 = 1 \\] Where: - \\(|0\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\\) - \\(|1\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\\) 2.12 Why Unit Vectors? 2.12.1 A Probabilistic System: A qubit represents a superposition of classical outcomes. Measurement outcomes are probabilistic, not deterministic. 2.12.2 Normalization Condition: Probabilities must sum to \\(1\\). For a qubit: \\[ |\\alpha|^2 + |\\beta|^2 = 1 \\] 2.12.3 The Born Rule: Upon measurement: - \\(\\text{Pr}(\\text{Outcome } |0\\rangle) = |\\alpha|^2\\) - \\(\\text{Pr}(\\text{Outcome } |1\\rangle) = |\\beta|^2\\) 2.13 Bloch Sphere Representation of Qubit States 2.13.1 Representation: A general single-qubit state is a unit vector in \\(\\mathbb{C}^2\\): \\[ |\\psi\\rangle = \\cos\\frac{\\theta}{2} |0\\rangle + e^{i\\phi} \\sin\\frac{\\theta}{2} |1\\rangle \\] Where: - \\(\\theta \\in [0, \\pi]\\): Weight of \\(|0\\rangle\\) and \\(|1\\rangle\\) - \\(\\phi \\in [0, 2\\pi)\\): Relative phase between \\(|0\\rangle\\) and \\(|1\\rangle\\) 2.13.2 Bloch Sphere Mapping: The state \\(|\\psi\\rangle\\) maps to a point \\(\\mathbf{r}\\) on the unit sphere: \\[ \\mathbf{r} = (\\langle \\sigma_x \\rangle, \\langle \\sigma_y \\rangle, \\langle \\sigma_z \\rangle) \\] Where: - \\(\\langle \\sigma_x \\rangle = \\sin\\theta \\cos\\phi\\) - \\(\\langle \\sigma_y \\rangle = \\sin\\theta \\sin\\phi\\) - \\(\\langle \\sigma_z \\rangle = \\cos\\theta\\) Global phase (\\(e^{i\\gamma}\\)) does not affect the Bloch sphere representation. 2.14 Quantum Gates: Processing Quantum Data 2.14.1 Classical vs. Quantum: Classical Gates: Perform logical operations (e.g., AND, OR, NOT). Quantum Gates: Perform transformations on qubits using unitary operations. 2.14.2 Why Unitary Matrices? Reversible: Quantum mechanics laws are reversible. Norm-Preserving: Probabilities must sum to \\(1\\). 2.14.3 Definition: A quantum gate is a \\(2 \\times 2\\) unitary matrix \\(U\\) satisfying: \\[ U^\\dagger U = I \\] 2.15 Classical and Quantum Gates 2.15.1 Classical NOT Gate: Matrix: \\[ \\text{NOT} = \\begin{bmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\] Action: - \\(\\text{NOT}(|0\\rangle) = |1\\rangle\\) - \\(\\text{NOT}(|1\\rangle) = |0\\rangle\\) 2.15.2 Quantum Phase Gate (\\(R_\\phi\\)): Matrix: \\[ R_\\phi = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; e^{i\\phi} \\end{bmatrix} \\] Action: \\[ R_\\phi (\\alpha|0\\rangle + \\beta|1\\rangle) = \\alpha|0\\rangle + \\beta e^{i\\phi} |1\\rangle \\] 2.16 Universal Gate Sets 2.16.1 Classical Universal Gates: Definition: A set of gates is universal if it can implement any Boolean function. Example: AND, OR, NOT (or NAND alone). 2.16.2 Quantum Universal Gates: Definition: A set of quantum gates is universal if any unitary operation can be approximated to arbitrary accuracy. 2.16.3 Examples (Single-Qubit Case): \\(\\{H, S, X\\}\\): Hadamard, Phase, Bit flip \\(\\{H, R_z(\\theta), X\\}\\): Hadamard, Z-axis rotation, Bit flip \\(\\{H, R_y(\\theta)\\}\\): Hadamard, Y-axis rotation \\(\\{X, Y, Z, H\\}\\): Pauli-X, Y, Z, Hadamard \\(\\{H, T, X\\}\\): Hadamard, T gate, Bit flip 2.17 Quantum Computing Notes 2.18 Hadamard Gate The Hadamard gate creates superposition by transforming basis states. Matrix Representation: \\[ H = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{pmatrix} \\] Action on Basis States: \\[ H|0⟩ = \\frac{|0⟩ + |1⟩}{\\sqrt{2}}, \\quad H|1⟩ = \\frac{|0⟩ - |1⟩}{\\sqrt{2}} \\] 2.19 Phase Gate (S Gate) The phase gate introduces a phase shift of \\(\\pi/2\\). Matrix Representation: \\[ S = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; i \\end{pmatrix} \\] Action on Basis States: \\[ S|0⟩ = |0⟩, \\quad S|1⟩ = i|1⟩ \\] 2.20 Arbitrary Phase Shift: \\(R_z(\\theta)\\) Gate This gate applies an arbitrary phase rotation around the z-axis. Matrix Representation: \\[ R_z(\\theta) = \\begin{pmatrix} e^{-i\\theta/2} &amp; 0 \\\\ 0 &amp; e^{i\\theta/2} \\end{pmatrix} \\] Action on Basis States: \\[ R_z(\\theta)|0⟩ = e^{-i\\theta/2}|0⟩ \\] \\[ R_z(\\theta)|1⟩ = e^{i\\theta/2}|1⟩ \\] 2.21 \\(R_y(\\theta)\\) Gate The \\(R_y(\\theta)\\) gate represents a rotation by an angle \\(\\theta\\) around the y-axis on the Bloch sphere. Matrix Representation: \\[ R_y(\\theta) = \\begin{pmatrix} \\cos(\\theta/2) &amp; -\\sin(\\theta/2) \\\\ \\sin(\\theta/2) &amp; \\cos(\\theta/2) \\end{pmatrix} \\] Action on Basis States: \\[ R_y(\\theta)|0⟩ = \\cos(\\theta/2)|0⟩ + \\sin(\\theta/2)|1⟩ \\] \\[ R_y(\\theta)|1⟩ = -\\sin(\\theta/2)|0⟩ + \\cos(\\theta/2)|1⟩ \\] 2.22 Pauli Gates: X, Y, and Z 2.22.1 Pauli-X (Bit-Flip Gate) Swaps \\(|0⟩\\) and \\(|1⟩\\), analogous to a classical NOT gate. Matrix Representation: \\[ X = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix} \\] Action on Basis States: \\[ X|0⟩ = |1⟩, \\quad X|1⟩ = |0⟩ \\] 2.22.2 Pauli-Y Gate Combines bit-flip and phase-flip operations. Matrix Representation: \\[ Y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix} \\] Action on Basis States: \\[ Y|0⟩ = i|1⟩, \\quad Y|1⟩ = -i|0⟩ \\] 2.22.3 Pauli-Z (Phase-Flip Gate) Leaves \\(|0⟩\\) unchanged but flips the phase of \\(|1⟩\\). Matrix Representation: \\[ Z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix} \\] Action on Basis States: \\[ Z|0⟩ = |0⟩, \\quad Z|1⟩ = -|1⟩ \\] 2.23 Quantum Measurement: Capturing Information 2.23.1 Key Idea In quantum computing, measurement extracts information from a quantum state, but the process is probabilistic and alters the state. Classical measurement gives a deterministic outcome without changing the system. Quantum measurement is inherently probabilistic and collapses the quantum state to a definite outcome. 2.24 Nature of Quantum Measurement 2.24.1 Physical Interpretation Measurement corresponds to observing a physical property (e.g., spin direction, polarization). Before measurement, the system exists in a superposition of states. Measurement collapses the superposition to one of the possible outcomes. 2.24.2 Mathematical Representation Measurement is modeled using projection operators \\(P_i\\). Each \\(P_i\\) corresponds to a possible measurement outcome. Probabilities and post-measurement states follow from these operators. 2.25 Formal Definition of Quantum Measurement Let \\(|ψ⟩\\) be a quantum state and \\(\\{P_i\\}\\) a set of projection operators: Probability of Outcome \\(i\\): \\[ p(i) = \\langle ψ|P_i|ψ⟩ \\] Post-Measurement State (if Outcome \\(i\\) Occurs): \\[ |ψ_i⟩ = \\frac{P_i |ψ⟩}{\\sqrt{p(i)}} \\] Projection Operators: \\[ P_i = |ϕ_i⟩⟨ϕ_i|, \\quad \\sum_i P_i = I \\] 2.26 Example: Measurement in an Orthogonal Basis 2.26.1 Initial State: \\[ |ψ⟩ = α|0⟩ + β|1⟩ \\] 2.26.2 Measurement in Computational Basis (\\(|0⟩, |1⟩\\)): Projection Operators: \\[ P_0 = |0⟩⟨0|, \\quad P_1 = |1⟩⟨1| \\] Probability of Measuring \\(|0⟩\\): \\[ p(0) = |α|^2 \\] Post-Measurement State: \\(|0⟩\\) Probability of Measuring \\(|1⟩\\): \\[ p(1) = |β|^2 \\] Post-Measurement State: \\(|1⟩\\) 2.27 Measurement in the \\(|+⟩\\) and \\(|-⟩\\) Basis 2.27.1 Given State: \\[ |ψ⟩ = \\sqrt{0.75}|0⟩ + \\sqrt{0.25}|1⟩ \\] 2.27.2 Overlaps: \\(\\langle+|ψ⟩ = \\frac{1}{\\sqrt{2}}(\\sqrt{0.75} + \\sqrt{0.25}) \\approx 0.96\\) \\(\\langle-|ψ⟩ = \\frac{1}{\\sqrt{2}}(\\sqrt{0.75} - \\sqrt{0.25}) \\approx 0.25\\) 2.27.3 Measurement Probabilities: \\(P(|+⟩) = |\\langle+|ψ⟩|^2 \\approx 0.93\\) \\(P(|-⟩) = |\\langle-|ψ⟩|^2 \\approx 0.07\\) 2.28 The Deutsch Problem 2.28.1 Problem: Given: A function \\(f : \\{0,1\\} \\to \\{0,1\\}\\). Task: Determine if \\(f\\) is constant or balanced. 2.28.2 Classical Approach: Requires two function evaluations in the worst case. 2.28.3 Quantum Goal: Use quantum computing to determine this in a single function call! 2.29 Deutsch Algorithm: Key Steps Input: Two qubits: First qubit: \\(|x\\rangle\\) (input qubit). Second qubit: \\(|y\\rangle\\) (auxiliary qubit, used for function evaluation). Prepare a Superposition: Apply Hadamard gates to each qubit to create a superposition: First qubit: \\(H |0\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\). Second qubit: \\(H |1\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)\\). Apply the Oracle \\(U_f\\): The oracle applies the transformation: \\[ U_f |x, y\\rangle = |x, y \\oplus f(x)\\rangle \\] This encodes \\(f(x)\\) in the second qubit. 2.30 Encoding Function Behavior via Phase Change Rewrite the second qubit in terms of a phase: \\[ U_f (H \\otimes H)|0,1\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + (-1)^{f(1) \\oplus f(0)} |1\\rangle)|-\\rangle \\] The first qubit now contains information about \\(f(x)\\). 2.31 Apply Hadamard Transform (Interference) Applying Hadamard again on the first qubit results in: \\[ H \\frac{1}{\\sqrt{2}}(|0\\rangle + (-1)^{f(1) \\oplus f(0)} |1\\rangle) \\] This step extracts global information about \\(f(x)\\). 2.32 Measurement Measure the first qubit: \\(|0\\rangle\\): \\(f(x)\\) is constant. \\(|1\\rangle\\): \\(f(x)\\) is balanced. The second qubit is ignored in the measurement. 2.33 The Quantum Approach Key Idea: Encode inputs into qubits. Apply a quantum oracle representing \\(f(x)\\). Quantum Advantage: By preparing a superposition of inputs, evaluate the function on both inputs in a single query. Interference allows extraction of the relevant information. Measurement at the end gives the answer deterministically. 2.34 Quantum Circuit for the Deutsch Algorithm 2.34.1 Explanation: Apply Hadamard gates to create superposition. Use the oracle \\(U_f\\) to introduce a phase based on \\(f(x)\\). Perform a final Hadamard to extract interference information. Measure the first qubit to determine whether \\(f\\) is constant or balanced. 2.35 Multi-Qubit Systems, Quantum Entanglement, and Higher-Dimensional Extensions 2.35.1 Two-Qubit State Space A single qubit state is a unit vector in \\(\\mathbb{C}^2\\). Two-qubit states reside in \\(\\mathbb{C}^2 \\otimes \\mathbb{C}^2\\) (denoted as \\(\\mathbb{C}^4\\)). 2.35.2 Basis Elements: \\(|00\\rangle, |01\\rangle, |10\\rangle, |11\\rangle\\). 2.35.3 Entanglement and Physical Interpretation Entanglement: A state \\(|\\psi\\rangle\\) is entangled if it cannot be written as a tensor product of two single-qubit states: \\[ |\\psi\\rangle \\neq |\\psi_1\\rangle \\otimes |\\psi_2\\rangle \\] Example of an entangled state: \\[ |\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle) \\] Example of a non-entangled state: \\[ |\\psi\\rangle = |0\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\] Physical Interpretation: Entangled states exhibit correlations that cannot be explained classically. Measurement outcomes of entangled qubits are correlated, regardless of distance. 2.35.4 Measurement Effects 2.35.4.1 Entangled State: Example: \\(|\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\\). Measurement on the first qubit: If \\(|0\\rangle\\): Collapse to \\(|00\\rangle\\). If \\(|1\\rangle\\): Collapse to \\(|11\\rangle\\). Conclusion: Measurement on one qubit determines the state of the other. 2.35.4.2 Separable State: Example: \\(|\\psi\\rangle = |0\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\). Measurement on the first qubit: The first qubit is always \\(|0\\rangle\\). Measurement on the second qubit: \\(|0\\rangle\\) or \\(|1\\rangle\\) with equal probability. 2.36 Summary of Measurement Effects 2.36.1 Entangled State: Measurement on one qubit affects the state of the other. Shows strong correlations. 2.36.2 Separable State: Measurement on one qubit does not affect the other. No correlations between outcomes. 2.36.3 Physical Interpretation: Entanglement exhibits “action at a distance”. Separable states behave independently. # hellp # Mathjax is still working A block \\[ 1+1 \\] or inline math like \\(\\alpha = x/y\\) ## Inserting an algorithm too You can use an algorithm code block using syntax from pseudocode.js by setting the fenced div attribute algorithm as below % This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition) \\begin{algorithm} \\caption{Quicksort} \\begin{algorithmic} \\PROCEDURE{Quicksort}{$A, p, r$} \\IF{$p &lt; r$} \\STATE $q = $ \\CALL{Partition}{$A, p, r$} \\STATE \\CALL{Quicksort}{$A, p, q - 1$} \\STATE \\CALL{Quicksort}{$A, q + 1, r$} \\ENDIF \\ENDPROCEDURE \\PROCEDURE{Partition}{$A, p, r$} \\STATE $x = A[r]$ \\STATE $i = p - 1$ \\FOR{$j = p$ \\TO $r - 1$} \\IF{$A[j] &lt; x$} \\STATE $i = i + 1$ \\STATE exchange $A[i]$ with $A[j]$ \\ENDIF \\STATE exchange $A[i]$ with $A[r]$ \\ENDFOR \\ENDPROCEDURE \\end{algorithmic} \\end{algorithm} ### Another one \\begin{algorithm} \\caption{The original \\textsf{Relief} algorithm for ranking predictor variables in classification models with two classes.} \\begin{algorithmic} \\STATE Initialize the predictor scores $S_j$ to zero; \\FOR{$i = 1\\ldots m$ randomly selected training set samples ($R_i$)} \\STATE Find the nearest miss and hit in the training set; \\FOR{$j = 1\\ldots p$ predictor variables} \\STATE Adjust the score for each predictor based on the proximity of $R_j$ to the nearest miss and hit:\\\\ $S_j = S_j - diff_j(R_j, Hit)^2/m + diff_j(R_j, Miss)^2/m$; \\ENDFOR \\ENDFOR \\end{algorithmic} \\end{algorithm} "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
